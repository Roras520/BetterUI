local BaseComponent = loadstring(game:HttpGet(githubDirectory("BaseComponent")))()
local TweenService = game:GetService("TweenService")

local Dropdown = {}
Dropdown.__index = Dropdown
setmetatable(Dropdown, BaseComponent)

-- Type definitions
export type DropdownConfig = {
    Name: string,
    Parent: Instance?,
    Position: UDim2?,
    Size: UDim2?,
    Text: string?,
    TextColor: Color3?,
    BackgroundColor: Color3?,
    BorderColor: Color3?,
    CornerRadius: UDim?,
    Font: Enum.Font?,
    TextSize: number?,
    Options: {string}?,
    DefaultOption: string?,
    Callback: ((string) -> ())?,
    Flag: string?,
}

export type Dropdown = BaseComponent.Component & {
    Text: string,
    TextColor: Color3,
    BackgroundColor: Color3,
    BorderColor: Color3,
    CornerRadius: UDim,
    Font: Enum.Font,
    TextSize: number,
    Options: {string},
    SelectedOption: string,
    Callback: ((string) -> ())?,
    Flag: string?,
    IsOpen: boolean,
    
    new: (config: DropdownConfig) -> Dropdown,
    SetText: (self: Dropdown, text: string) -> boolean,
    SetOptions: (self: Dropdown, options: {string}) -> boolean,
    SetSelectedOption: (self: Dropdown, option: string) -> boolean,
    SetCallback: (self: Dropdown, callback: (string) -> ()) -> boolean,
    GetSelectedOption: (self: Dropdown) -> string,
    Toggle: (self: Dropdown) -> boolean,
    Close: (self: Dropdown) -> boolean,
    Open: (self: Dropdown) -> boolean,
}

-- Constants
local DEFAULT_ANIMATION_SPEED = 0.2
local DEFAULT_OPTION_HEIGHT = 25
local MAX_VISIBLE_OPTIONS = 5

-- Constructor
function Dropdown.new(config: DropdownConfig): Dropdown
    if not config or type(config) ~= "table" then
        error("Dropdown: Invalid config provided")
    end
    
    local self = BaseComponent.new(config)
    setmetatable(self, Dropdown)
    
    self.Text = config.Text or "Dropdown"
    self.TextColor = config.TextColor or Color3.fromRGB(255, 255, 255)
    self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(50, 50, 50)
    self.BorderColor = config.BorderColor or Color3.fromRGB(100, 100, 100)
    self.CornerRadius = config.CornerRadius or UDim.new(0, 6)
    self.Font = config.Font or Enum.Font.Gotham
    self.TextSize = config.TextSize or 14
    self.Options = config.Options or {}
    self.SelectedOption = config.DefaultOption or (self.Options[1] or "")
    self.Callback = config.Callback
    self.Flag = config.Flag
    self.IsOpen = false

    local success, result = pcall(function()
        local frame = Instance.new("Frame")
        frame.Name = self.Name
        frame.Size = config.Size or UDim2.new(0, 200, 0, 30)
        frame.Position = config.Position or UDim2.new(0, 0, 0, 0)
        frame.BackgroundTransparency = 1
        frame.ClipsDescendants = true
        frame.Parent = config.Parent
        
        local button = Instance.new("TextButton")
        button.Name = "Button"
        button.Size = UDim2.new(1, 0, 0, 30)
        button.Position = UDim2.new(0, 0, 0, 0)
        button.BackgroundColor3 = self.BackgroundColor
        button.TextColor3 = self.TextColor
        button.Text = self.SelectedOption
        button.Font = self.Font
        button.TextSize = self.TextSize
        button.TextXAlignment = Enum.TextXAlignment.Left
        button.AutoButtonColor = false
        button.Parent = frame
        
        local buttonCorner = Instance.new("UICorner")
        buttonCorner.CornerRadius = self.CornerRadius
        buttonCorner.Parent = button
        
        local buttonBorder = Instance.new("UIStroke")
        buttonBorder.Color = self.BorderColor
        buttonBorder.Thickness = 1
        buttonBorder.Parent = button
        
        local arrow = Instance.new("TextLabel")
        arrow.Name = "Arrow"
        arrow.Size = UDim2.new(0, 20, 0, 20)
        arrow.Position = UDim2.new(1, -25, 0.5, -10)
        arrow.BackgroundTransparency = 1
        arrow.Text = "â–¼"
        arrow.TextColor3 = self.TextColor
        arrow.Font = self.Font
        arrow.TextSize = 12
        arrow.TextXAlignment = Enum.TextXAlignment.Center
        arrow.Parent = button
        
        local optionsFrame = Instance.new("Frame")
        optionsFrame.Name = "OptionsFrame"
        optionsFrame.Size = UDim2.new(1, 0, 0, 0)
        optionsFrame.Position = UDim2.new(0, 0, 0, 30)
        optionsFrame.BackgroundColor3 = self.BackgroundColor
        optionsFrame.Parent = frame
        
        local optionsCorner = Instance.new("UICorner")
        optionsCorner.CornerRadius = self.CornerRadius
        optionsCorner.Parent = optionsFrame
        
        local optionsBorder = Instance.new("UIStroke")
        optionsBorder.Color = self.BorderColor
        optionsBorder.Thickness = 1
        optionsBorder.Parent = optionsFrame
        
        local scrollingFrame = Instance.new("ScrollingFrame")
        scrollingFrame.Name = "ScrollingFrame"
        scrollingFrame.Size = UDim2.new(1, 0, 1, 0)
        scrollingFrame.Position = UDim2.new(0, 0, 0, 0)
        scrollingFrame.BackgroundTransparency = 1
        scrollingFrame.BorderSizePixel = 0
        scrollingFrame.ScrollBarThickness = 4
        scrollingFrame.ScrollBarImageColor3 = self.TextColor
        scrollingFrame.Parent = optionsFrame
        
        local listLayout = Instance.new("UIListLayout")
        listLayout.SortOrder = Enum.SortOrder.LayoutOrder
        listLayout.Padding = UDim.new(0, 1)
        listLayout.Parent = scrollingFrame
        
        self.Instance = frame
        self.Button = button
        self.Arrow = arrow
        self.OptionsFrame = optionsFrame
        self.ScrollingFrame = scrollingFrame
        self.ListLayout = listLayout
        
        self:_setupInteractionHandling()
        
        self:_createOptions()
    end)
    
    if not success then
        error("Dropdown: Failed to create dropdown instance: " .. tostring(result))
    end
    
    return self
end

-- Setup interaction handling
function Dropdown:_setupInteractionHandling()
    if not self.Button then return end
    
    self:Connect("Activated", function()
        self:Toggle()
    end)
end

function Dropdown:_createOptions()
    if not self.ScrollingFrame then return end
    
    local success, result = pcall(function()
        for _, child in pairs(self.ScrollingFrame:GetChildren()) do
            if child:IsA("TextButton") then
                child:Destroy()
            end
        end
        
        for i, option in ipairs(self.Options) do
            local optionButton = Instance.new("TextButton")
            optionButton.Name = "Option" .. i
            optionButton.Size = UDim2.new(1, 0, 0, DEFAULT_OPTION_HEIGHT)
            optionButton.BackgroundTransparency = 1
            optionButton.Text = option
            optionButton.TextColor3 = self.TextColor
            optionButton.Font = self.Font
            optionButton.TextSize = self.TextSize
            optionButton.TextXAlignment = Enum.TextXAlignment.Left
            optionButton.AutoButtonColor = false
            optionButton.Parent = self.ScrollingFrame
            
            optionButton.MouseEnter:Connect(function()
                if not self.IsOpen then return end
                optionButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
            end)
            
            optionButton.MouseLeave:Connect(function()
                if not self.IsOpen then return end
                optionButton.BackgroundTransparency = 1
            end)
            
            optionButton.MouseButton1Click:Connect(function()
                self:SetSelectedOption(option)
                self:Close()
            end)
        end
        
        local totalHeight = math.min(#self.Options * (DEFAULT_OPTION_HEIGHT + 1), MAX_VISIBLE_OPTIONS * (DEFAULT_OPTION_HEIGHT + 1))
        self.ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, #self.Options * (DEFAULT_OPTION_HEIGHT + 1))
    end)
    
    if not success then
        warn("Dropdown: Failed to create options:", result)
    end
end

function Dropdown:_updateVisualState()
    if not self.OptionsFrame or not self.Arrow then return end
    
    local success, result = pcall(function()
        local targetSize = self.IsOpen and UDim2.new(1, 0, 0, math.min(#self.Options * (DEFAULT_OPTION_HEIGHT + 1), MAX_VISIBLE_OPTIONS * (DEFAULT_OPTION_HEIGHT + 1))) or UDim2.new(1, 0, 0, 0)
        local targetRotation = self.IsOpen and 180 or 0
        
        local frameTween = TweenService:Create(
            self.OptionsFrame,
            TweenInfo.new(DEFAULT_ANIMATION_SPEED, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = targetSize}
        )
        frameTween:Play()
        
        local arrowTween = TweenService:Create(
            self.Arrow,
            TweenInfo.new(DEFAULT_ANIMATION_SPEED, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Rotation = targetRotation}
        )
        arrowTween:Play()
    end)
    
    if not success then
        warn("Dropdown: Failed to update visual state:", result)
    end
end

function Dropdown:SetText(text: string): boolean
    if not text or type(text) ~= "string" then
        warn("Dropdown: Invalid text provided")
        return false
    end
    
    local success, result = pcall(function()
        self.Text = text
        if self.Button then
            self.Button.Text = text
        end
    end)
    
    if not success then
        warn("Dropdown: Failed to set text:", result)
        return false
    end
    
    return true
end

function Dropdown:SetOptions(options: {string}): boolean
    if not options or type(options) ~= "table" then
        warn("Dropdown: Options must be a table")
        return false
    end
    
    local success, result = pcall(function()
        self.Options = options
        self:_createOptions()
        
        if not table.find(self.Options, self.SelectedOption) then
            self.SelectedOption = self.Options[1] or ""
            if self.Button then
                self.Button.Text = self.SelectedOption
            end
        end
    end)
    
    if not success then
        warn("Dropdown: Failed to set options:", result)
        return false
    end
    
    return true
end

function Dropdown:SetSelectedOption(option: string): boolean
    if not option or type(option) ~= "string" then
        warn("Dropdown: Invalid option provided")
        return false
    end
    
    if not table.find(self.Options, option) then
        warn("Dropdown: Option '" .. option .. "' not found in options")
        return false
    end
    
    local success, result = pcall(function()
        local oldOption = self.SelectedOption
        self.SelectedOption = option
        
        if self.Button then
            self.Button.Text = option
        end
        
        if self.SelectedOption ~= oldOption and self.Callback then
            local callbackSuccess, callbackResult = pcall(self.Callback, option)
            if not callbackSuccess then
                warn("Dropdown: Callback failed:", callbackResult)
            end
        end
    end)
    
    if not success then
        warn("Dropdown: Failed to set selected option:", result)
        return false
    end
    
    return true
end

function Dropdown:SetCallback(callback: (string) -> ()): boolean
    if callback and type(callback) ~= "function" then
        warn("Dropdown: Callback must be a function")
        return false
    end
    
    self.Callback = callback
    return true
end

function Dropdown:GetSelectedOption(): string
    return self.SelectedOption
end

function Dropdown:Toggle(): boolean
    if self.IsOpen then
        return self:Close()
    else
        return self:Open()
    end
end

function Dropdown:Close(): boolean
    if not self.IsOpen then
        return true
    end
    
    local success, result = pcall(function()
        self.IsOpen = false
        self:_updateVisualState()
    end)
    
    if not success then
        warn("Dropdown: Failed to close:", result)
        return false
    end
    
    return true
end

function Dropdown:Open(): boolean
    if self.IsOpen then
        return true
    end
    
    local success, result = pcall(function()
        self.IsOpen = true
        self:_updateVisualState()
    end)
    
    if not success then
        warn("Dropdown: Failed to open:", result)
        return false
    end
    
    return true
end

return Dropdown
