local BaseComponent = loadstring(game:HttpGet(githubDirectory("BaseComponent")))()
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local Slider = {}
Slider.__index = Slider
setmetatable(Slider, BaseComponent)

-- Type definitions
export type SliderConfig = {
    Name: string,
    Parent: Instance?,
    Position: UDim2?,
    Size: UDim2?,
    Text: string?,
    TextColor: Color3?,
    BackgroundColor: Color3?,
    FillColor: Color3?,
    HandleColor: Color3?,
    BorderColor: Color3?,
    CornerRadius: UDim?,
    Font: Enum.Font?,
    TextSize: number?,
    MinValue: number?,
    MaxValue: number?,
    DefaultValue: number?,
    Step: number?,
    Precision: number?,
    Callback: ((number) -> ())?,
    Flag: string?,
}

export type Slider = BaseComponent.Component & {
    Text: string,
    TextColor: Color3,
    BackgroundColor: Color3,
    FillColor: Color3,
    HandleColor: Color3,
    BorderColor: Color3,
    CornerRadius: UDim,
    Font: Enum.Font,
    TextSize: number,
    MinValue: number,
    MaxValue: number,
    Value: number,
    Step: number,
    Precision: number,
    Callback: ((number) -> ())?,
    Flag: string?,
    IsDragging: boolean,
    
    new: (config: SliderConfig) -> Slider,
    SetText: (self: Slider, text: string) -> boolean,
    SetValue: (self: Slider, value: number) -> boolean,
    SetRange: (self: Slider, minValue: number, maxValue: number) -> boolean,
    SetCallback: (self: Slider, callback: (number) -> ()) -> boolean,
    GetValue: (self: Slider) -> number,
    GetPercentage: (self: Slider) -> number,
}

-- Constants
local DEFAULT_ANIMATION_SPEED = 0.15
local DEFAULT_HANDLE_SIZE = 16

-- Constructor
function Slider.new(config: SliderConfig): Slider
    if not config or type(config) ~= "table" then
        error("Slider: Invalid config provided")
    end
    
    local self = BaseComponent.new(config)
    setmetatable(self, Slider)
    
    self.Text = config.Text or "Slider"
    self.TextColor = config.TextColor or Color3.fromRGB(255, 255, 255)
    self.BackgroundColor = config.BackgroundColor or Color3.fromRGB(50, 50, 50)
    self.FillColor = config.FillColor or Color3.fromRGB(100, 200, 100)
    self.HandleColor = config.HandleColor or Color3.fromRGB(255, 255, 255)
    self.BorderColor = config.BorderColor or Color3.fromRGB(100, 100, 100)
    self.CornerRadius = config.CornerRadius or UDim.new(0, 8)
    self.Font = config.Font or Enum.Font.Gotham
    self.TextSize = config.TextSize or 14
    self.MinValue = config.MinValue or 0
    self.MaxValue = config.MaxValue or 100
    self.Value = config.DefaultValue or self.MinValue
    self.Step = config.Step or 1
    self.Precision = config.Precision or 0
    self.Callback = config.Callback
    self.Flag = config.Flag
    self.IsDragging = false
    
    -- Validate values
    if self.MinValue >= self.MaxValue then
        error("Slider: MinValue must be less than MaxValue")
    end
    
    if self.Value < self.MinValue or self.Value > self.MaxValue then
        self.Value = self.MinValue
    end
    
    local success, result = pcall(function()
        local frame = Instance.new("Frame")
        frame.Name = self.Name
        frame.Size = config.Size or UDim2.new(0, 200, 0, 40)
        frame.Position = config.Position or UDim2.new(0, 0, 0, 0)
        frame.BackgroundTransparency = 1
        frame.Parent = config.Parent
        
        local textLabel = Instance.new("TextLabel")
        textLabel.Name = "TextLabel"
        textLabel.Size = UDim2.new(1, 0, 0, 20)
        textLabel.Position = UDim2.new(0, 0, 0, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.Text = self.Text
        textLabel.TextColor3 = self.TextColor
        textLabel.Font = self.Font
        textLabel.TextSize = self.TextSize
        textLabel.TextXAlignment = Enum.TextXAlignment.Left
        textLabel.Parent = frame
        
        local valueLabel = Instance.new("TextLabel")
        valueLabel.Name = "ValueLabel"
        valueLabel.Size = UDim2.new(0, 60, 0, 20)
        valueLabel.Position = UDim2.new(1, -60, 0, 0)
        valueLabel.BackgroundTransparency = 1
        valueLabel.Text = tostring(self.Value)
        valueLabel.TextColor3 = self.TextColor
        valueLabel.Font = self.Font
        valueLabel.TextSize = self.TextSize
        valueLabel.TextXAlignment = Enum.TextXAlignment.Right
        valueLabel.Parent = frame
        
        local track = Instance.new("Frame")
        track.Name = "Track"
        track.Size = UDim2.new(1, 0, 0, 8)
        track.Position = UDim2.new(0, 0, 0, 25)
        track.BackgroundColor3 = self.BackgroundColor
        track.Parent = frame
        
        local trackCorner = Instance.new("UICorner")
        trackCorner.CornerRadius = self.CornerRadius
        trackCorner.Parent = track
        
        local fill = Instance.new("Frame")
        fill.Name = "Fill"
        fill.Size = UDim2.new(0, 0, 1, 0)
        fill.Position = UDim2.new(0, 0, 0, 0)
        fill.BackgroundColor3 = self.FillColor
        fill.Parent = track
        
        local fillCorner = Instance.new("UICorner")
        fillCorner.CornerRadius = self.CornerRadius
        fillCorner.Parent = fill
        
        local handle = Instance.new("Frame")
        handle.Name = "Handle"
        handle.Size = UDim2.new(0, DEFAULT_HANDLE_SIZE, 0, DEFAULT_HANDLE_SIZE)
        handle.Position = UDim2.new(0, -DEFAULT_HANDLE_SIZE/2, 0.5, -DEFAULT_HANDLE_SIZE/2)
        handle.BackgroundColor3 = self.HandleColor
        handle.Parent = track
        
        local handleCorner = Instance.new("UICorner")
        handleCorner.CornerRadius = UDim.new(0, DEFAULT_HANDLE_SIZE/2)
        handleCorner.Parent = handle
        
        local clickDetector = Instance.new("TextButton")
        clickDetector.Name = "ClickDetector"
        clickDetector.Size = UDim2.new(1, 0, 1, 0)
        clickDetector.Position = UDim2.new(0, 0, 0, 0)
        clickDetector.BackgroundTransparency = 1
        clickDetector.Text = ""
        clickDetector.Parent = frame
        
        self.Instance = frame
        self.TextLabel = textLabel
        self.ValueLabel = valueLabel
        self.Track = track
        self.Fill = fill
        self.Handle = handle
        self.ClickDetector = clickDetector
        
        self:_setupInteractionHandling()
        
        self:_updateVisualState()
    end)
    
    if not success then
        error("Slider: Failed to create slider instance: " .. tostring(result))
    end
    
    return self
end

function Slider:_setupInteractionHandling()
    if not self.ClickDetector then return end
    
    self:Connect("MouseButton1Down", function()
        self.IsDragging = true
        self:_updateValueFromMouse()
    end)
    
    self:Connect("MouseButton1Up", function()
        self.IsDragging = false
    end)
    
    self:Connect("MouseMoved", function()
        if self.IsDragging then
            self:_updateValueFromMouse()
        end
    end)
    
    local mouseUpConnection = UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            self.IsDragging = false
        end
    end)
    
    table.insert(self.Connections, mouseUpConnection)
end

function Slider:_updateValueFromMouse()
    if not self.Track then return end
    
    local success, result = pcall(function()
        local mouseX = UserInputService:GetMouseLocation().X
        local trackAbsolutePosition = self.Track.AbsolutePosition.X
        local trackAbsoluteSize = self.Track.AbsoluteSize.X
        
        local relativeX = math.clamp(mouseX - trackAbsolutePosition, 0, trackAbsoluteSize)
        local percentage = relativeX / trackAbsoluteSize
        
        local newValue = self.MinValue + (percentage * (self.MaxValue - self.MinValue))
        newValue = math.clamp(newValue, self.MinValue, self.MaxValue)
        
        if self.Step > 0 then
            newValue = math.floor(newValue / self.Step + 0.5) * self.Step
        end
        
        if self.Precision > 0 then
            newValue = math.floor(newValue * (10 ^ self.Precision) + 0.5) / (10 ^ self.Precision)
        end
        
        self:SetValue(newValue)
    end)
    
    if not success then
        warn("Slider: Failed to update value from mouse:", result)
    end
end

function Slider:_updateVisualState()
    if not self.Fill or not self.Handle or not self.ValueLabel then return end
    
    local success, result = pcall(function()
        local percentage = (self.Value - self.MinValue) / (self.MaxValue - self.MinValue)
        local trackSize = self.Track.AbsoluteSize.X
        local fillWidth = percentage * trackSize
        
        local fillTween = TweenService:Create(
            self.Fill,
            TweenInfo.new(DEFAULT_ANIMATION_SPEED, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Size = UDim2.new(0, fillWidth, 1, 0)}
        )
        fillTween:Play()
        
        local handlePosition = UDim2.new(0, fillWidth - DEFAULT_HANDLE_SIZE/2, 0.5, -DEFAULT_HANDLE_SIZE/2)
        local handleTween = TweenService:Create(
            self.Handle,
            TweenInfo.new(DEFAULT_ANIMATION_SPEED, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Position = handlePosition}
        )
        handleTween:Play()
        
        local displayValue = self.Precision > 0 and string.format("%." .. self.Precision .. "f", self.Value) or tostring(self.Value)
        self.ValueLabel.Text = displayValue
    end)
    
    if not success then
        warn("Slider: Failed to update visual state:", result)
    end
end

function Slider:SetText(text: string): boolean
    if not text or type(text) ~= "string" then
        warn("Slider: Invalid text provided")
        return false
    end
    
    local success, result = pcall(function()
        self.Text = text
        if self.TextLabel then
            self.TextLabel.Text = text
        end
    end)
    
    if not success then
        warn("Slider: Failed to set text:", result)
        return false
    end
    
    return true
end

function Slider:SetValue(value: number): boolean
    if type(value) ~= "number" then
        warn("Slider: Value must be a number")
        return false
    end
    
    local success, result = pcall(function()
        local oldValue = self.Value
        self.Value = math.clamp(value, self.MinValue, self.MaxValue)
        
        if self.Step > 0 then
            self.Value = math.floor(self.Value / self.Step + 0.5) * self.Step
        end
        
        if self.Precision > 0 then
            self.Value = math.floor(self.Value * (10 ^ self.Precision) + 0.5) / (10 ^ self.Precision)
        end
        
        self:_updateVisualState()
        
        if self.Value ~= oldValue and self.Callback then
            local callbackSuccess, callbackResult = pcall(self.Callback, self.Value)
            if not callbackSuccess then
                warn("Slider: Callback failed:", callbackResult)
            end
        end
    end)
    
    if not success then
        warn("Slider: Failed to set value:", result)
        return false
    end
    
    return true
end

function Slider:SetRange(minValue: number, maxValue: number): boolean
    if type(minValue) ~= "number" or type(maxValue) ~= "number" then
        warn("Slider: Range values must be numbers")
        return false
    end
    
    if minValue >= maxValue then
        warn("Slider: MinValue must be less than MaxValue")
        return false
    end
    
    local success, result = pcall(function()
        self.MinValue = minValue
        self.MaxValue = maxValue
        self.Value = math.clamp(self.Value, minValue, maxValue)
        self:_updateVisualState()
    end)
    
    if not success then
        warn("Slider: Failed to set range:", result)
        return false
    end
    
    return true
end

function Slider:SetCallback(callback: (number) -> ()): boolean
    if callback and type(callback) ~= "function" then
        warn("Slider: Callback must be a function")
        return false
    end
    
    self.Callback = callback
    return true
end

function Slider:GetValue(): number
    return self.Value
end

function Slider:GetPercentage(): number
    return (self.Value - self.MinValue) / (self.MaxValue - self.MinValue)
end

return Slider
